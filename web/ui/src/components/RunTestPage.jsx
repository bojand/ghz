import React, { useState, useEffect, useMemo } from 'react'
import { Pane, TextInput, Textarea, Button, Checkbox, Heading, Text, Spinner, Alert, Select, IconButton } from 'evergreen-ui'
import { useHistory, useParams } from 'react-router-dom'
import * as protobuf from 'protobufjs'

export default function RunTestPage () {
  const history = useHistory()
  const { projectId } = useParams()
  const [form, setForm] = useState({
    call: '', host: 'localhost:', concurrency: 50, total: 200, duration_sec: 0,
    data: '{"name":"bob"}', metadata: '{}', tags: '{}', insecure: true, proto_file: '', async: false
  })
  const [loading, setLoading] = useState(false)
  const [error, setError] = useState(null)
  // Project Status
  const [projects, setProjects] = useState([])
  const [projectsLoading, setProjectsLoading] = useState(false)
  const [projectsError, setProjectsError] = useState(null)
  // selectedProjectID: first to use URL param (if it can); rather than generate random project name
  const [selectedProjectId, setSelectedProjectId] = useState(projectId || '')
  // proto 解析相关状态
  const [protoError, setProtoError] = useState(null)
  const [services, setServices] = useState([]) // [{name, fullName, methods:[{name, fullName, requestType}]}]
  const [selectedService, setSelectedService] = useState('')
  const [selectedMethod, setSelectedMethod] = useState('')
  const [autoGenerated, setAutoGenerated] = useState(false) // 标记 data 是否由自动生成，可在用户修改后重置

  // 初始化：加载缓存
  useEffect(() => {
    try {
      const saved = localStorage.getItem('run.form')
      if (saved) {
        const obj = JSON.parse(saved)
        setForm(f => ({ ...f, ...obj }))
      }
    } catch { /* ignore */ }
  }, [])

  // 缓存：表单任一字段变化即写入（简单策略，可根据需要节流）
  useEffect(() => {
    try {
      localStorage.setItem('run.form', JSON.stringify(form))
    } catch { /* ignore */ }
  }, [form.call, form.host, form.concurrency, form.total, form.duration_sec, form.data, form.metadata, form.tags, form.insecure, form.proto_file, form.async])

  // Async job state
  const [jobId, setJobId] = useState(null)
  const [jobStatus, setJobStatus] = useState(null)
  const [jobError, setJobError] = useState(null)
  const [polling, setPolling] = useState(false)
  const pollingRef = React.useRef(null)

  const stopPolling = () => {
    if (pollingRef.current) {
      clearInterval(pollingRef.current)
      pollingRef.current = null
    }
    setPolling(false)
  }

  useEffect(() => () => stopPolling(), [])

  const startPolling = (jid) => {
    setPolling(true)
    setJobStatus('PENDING')
    pollingRef.current = setInterval(async () => {
      try {
        const r = await fetch(`/api/run/jobs/${jid}/`)
        if (!r.ok) throw new Error(await r.text())
        const j = await r.json()
        setJobStatus(j.status)
        if (j.status === 'SUCCEEDED') {
          stopPolling()
          if (j.result && j.result.report && j.result.report.id) {
            history.push(`/reports/${j.result.report.id}`)
          }
        } else if (j.status === 'FAILED') {
          stopPolling()
          setJobError(j.error || 'Job failed')
        }
      } catch (e) {
        stopPolling()
        setJobError(e.message)
      }
    }, 2000)
  }

  // load project list
  useEffect(() => {
    let ignore = false
    const fetchProjects = async () => {
      setProjectsLoading(true)
      setProjectsError(null)
      try {
        const res = await fetch('/api/projects/')
        if (!res.ok) throw new Error(await res.text())
        const body = await res.json()
        if (!ignore && body && Array.isArray(body.data)) {
          setProjects(body.data)
          if (!projectId && body.data.length === 1) {
            setSelectedProjectId(String(body.data[0].id))
          }
        }
      } catch (e) {
        if (!ignore) setProjectsError(e.message)
      } finally {
        if (!ignore) setProjectsLoading(false)
      }
    }
    fetchProjects()
    return () => { ignore = true }
  }, [projectId])

  const update = (k, v) => setForm(f => ({ ...f, [k]: v }))

  // 解析 proto
  useEffect(() => {
    const txt = form.proto_file.trim()
    setProtoError(null)
    setServices([])
    setSelectedService('')
    setSelectedMethod('')
    if (!txt) return
    // protobufjs 期望文件, 我们使用 parse
    try {
      const parsed = protobuf.parse(txt, { keepCase: true })
      const root = parsed.root
      const srvs = []
      root.nestedArray.forEach(n => {
        collectServices(n, '', srvs)
      })
      setServices(srvs)
      // 如果只有一个服务自动选择
      if (srvs.length === 1) {
        setSelectedService(srvs[0].fullName)
        if (srvs[0].methods.length === 1) {
          setSelectedMethod(srvs[0].methods[0].fullName)
        }
      }
    } catch (e) {
      setProtoError(e.message)
    }
  }, [form.proto_file])

  const collectServices = (node, prefix, out) => {
    if (!node) return
    const currentPrefix = node.name ? (prefix ? prefix + '.' + node.name : node.name) : prefix
    if (node.methods) {
      const methods = Object.keys(node.methods).map(mn => {
        const m = node.methods[mn]
        return {
          name: mn,
            fullName: currentPrefix + '.' + mn,
            requestType: m.requestType,
            responseType: m.responseType
        }
      })
      out.push({ name: node.name, fullName: currentPrefix, methods })
    }
    if (node.nested) {
      Object.keys(node.nested).forEach(k => {
        const child = node.nested[k]
        if (child) collectServices(child, currentPrefix, out)
      })
    }
  }

  // 根据选定方法生成请求骨架
  useEffect(() => {
    if (!selectedMethod) return
    const svc = services.find(s => s.methods.some(m => m.fullName === selectedMethod))
    if (!svc) return
    const method = svc.methods.find(m => m.fullName === selectedMethod)
    if (!method) return
    try {
      const txt = form.proto_file.trim()
      if (!txt) return
      const parsed = protobuf.parse(txt, { keepCase: true })
      const root = parsed.root
      const type = root.lookupType(method.requestType)
      const obj = generateMessageSkeleton(type)
      const jsonStr = JSON.stringify(obj, null, 2)
      update('data', jsonStr)
      setAutoGenerated(true)
      update('call', selectedMethod)
    } catch (e) {
      // Only Record
      console.warn('generate skeleton failed', e)
    }
  }, [selectedMethod])

  // If user edit data, cancel autoGenerated flag
  const onChangeData = e => {
    if (autoGenerated) setAutoGenerated(false)
    update('data', e.target.value)
  }

  const generateMessageSkeleton = (type) => {
    if (!type || !type.fields) return {}
    const obj = {}
    Object.keys(type.fields).forEach(fname => {
      const f = type.fields[fname]
      const repeated = !!f.repeated
      const kind = f.resolvedType ? (f.resolvedType.fields ? 'message' : f.resolvedType.values ? 'enum' : 'other') : f.type
      const assignValue = () => {
        switch (f.type) {
          case 'string': return ''
          case 'bool': return false
          case 'double':
          case 'float':
          case 'int32':
          case 'uint32':
          case 'sint32':
          case 'fixed32':
          case 'sfixed32':
          case 'int64':
          case 'uint64':
          case 'sint64':
          case 'fixed64':
          case 'sfixed64':
            return 0
          case 'bytes': return ''
          default:
            if (kind === 'message') {
              return generateMessageSkeleton(f.resolvedType)
            }
            if (kind === 'enum') {
              // use first enmu value
              const vals = Object.keys(f.resolvedType.values || {})
              return vals.length ? vals[0] : 0
            }
            return null
        }
      }
      const val = assignValue()
      obj[fname] = repeated ? [val] : val
    })
    return obj
  }

  const submit = async () => {
    setError(null)
    let payload
    try {
      payload = {
        call: form.call.trim(),
        host: form.host.trim(),
        concurrency: Number(form.concurrency),
        total: Number(form.total),
        duration_sec: Number(form.duration_sec),
        insecure: !!form.insecure,
        proto_file: form.proto_file,
        data: JSON.parse(form.data || '{}'),
        metadata: JSON.parse(form.metadata || '{}'),
        tags: JSON.parse(form.tags || '{}'),
        async: !!form.async
      }
    } catch (e) {
      setError('failed to parse JSON: ' + e.message)
      return
    }
    if (!payload.call || !payload.host) {
      setError('call and host is required')
      return
    }
    if (payload.total > 0 && payload.duration_sec > 0) {
      setError('total and duration_sec can only be one of them')
      return
    }
    setLoading(true)
    const pid = selectedProjectId || ''
    const url = pid ? `/api/projects/${pid}/run/` : '/api/run/'
    try {
      const res = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) })
      if (res.status === 202) {
        const j = await res.json()
        if (j.job_id) {
          setJobId(j.job_id)
          setJobStatus(j.status)
          startPolling(j.job_id)
        } else {
          setError('missing job_id')
        }
      } else if (res.status === 201) {
        const data = await res.json()
        if (data && data.report && data.report.id) {
          history.push(`/reports/${data.report.id}`)
        } else {
          setError('need report.id')
        }
      } else if (!res.ok) {
        const txt = await res.text()
        throw new Error(txt)
      } else {
        const data = await res.json()
        if (data && data.report && data.report.id) {
          history.push(`/reports/${data.report.id}`)
        } else {
          setError('need report.id')
        }
      }
    } catch (e) {
      setError(e.message)
    } finally {
      setLoading(false)
    }
  }

  return (
    <Pane padding={16}>
      <Heading size={700} marginBottom={12}>Run gRPC Load Test</Heading>
      <Pane marginBottom={12}>
        <Heading size={500} marginBottom={4}>Select Project</Heading>
        {projectsLoading && <Text size={300}>Load Project...</Text>}
        {projectsError && <Alert intent='danger' title='Failed' marginBottom={8}>{projectsError}</Alert>}
        <Select
          width={320}
          value={selectedProjectId}
          onChange={e => setSelectedProjectId(e.target.value)}
          disabled={projectsLoading || !!projectId}
        >
          <option value=''>Temporary</option>
          {projects.map(p => (
            <option key={p.id} value={p.id}>{p.name || `Project #${p.id}`}</option>
          ))}
        </Select>
        {projectId && <Text marginTop={4} display='block' size={300} color='muted'>项目通过 URL 指定，不能修改</Text>}
      </Pane>
      <Pane marginBottom={16}>
        <Heading size={500} marginBottom={4}>Proto Services & Methods</Heading>
        {protoError && <Alert intent='danger' title='Proto Parse Error' marginBottom={8}>{protoError}</Alert>}
        {services.length === 0 && !protoError && form.proto_file.trim() && <Text size={300}>No services found.</Text>}
        {services.length > 0 && (
          <Pane display='flex' gap={8} marginBottom={8} flexWrap='wrap'>
            <Pane>
              <Text size={300} display='block' marginBottom={4}>Service</Text>
              <Select width={300} value={selectedService} onChange={e => { setSelectedService(e.target.value); setSelectedMethod('') }}>
                <option value=''>-- select service --</option>
                {services.map(s => <option key={s.fullName} value={s.fullName}>{s.fullName}</option>)}
              </Select>
            </Pane>
            <Pane>
              <Text size={300} display='block' marginBottom={4}>Method</Text>
              <Select width={300} value={selectedMethod} onChange={e => setSelectedMethod(e.target.value)} disabled={!selectedService}>
                <option value=''>-- select method --</option>
                {services.filter(s => s.fullName === selectedService).flatMap(s => s.methods).map(m => <option key={m.fullName} value={m.fullName}>{m.name}</option>)}
              </Select>
            </Pane>
            <Pane alignSelf='flex-end'>
              <IconButton icon='refresh' appearance='minimal' intent='none' onClick={() => setSelectedMethod(selectedMethod)} title='Regenerate JSON (overwrite data)' disabled={!selectedMethod} />
            </Pane>
          </Pane>
        )}
        {autoGenerated && <Text size={300} color='muted'>Auto generate request JSON Body, and edit it directly</Text>}
      </Pane>
      {error && <Alert intent='danger' title='Error' marginBottom={12}>{error}</Alert>}
      <Pane display='flex' flexDirection='column' maxWidth={820}>
        <label>Call (eg: helloworld.Greeter.SayHello)</label>
        <TextInput value={form.call} onChange={e => update('call', e.target.value)} marginBottom={8} />
        <label>Host (eg: localhost:50051)</label>
        <TextInput value={form.host} onChange={e => update('host', e.target.value)} marginBottom={8} />
        <Pane display='flex' gap={8}>
          <Pane flex={1}>
            <label>Concurrency</label>
            <TextInput type='number' value={form.concurrency} onChange={e => update('concurrency', e.target.value)} marginBottom={8} />
          </Pane>
          <Pane flex={1}>
            <label>Total Requests</label>
            <TextInput type='number' value={form.total} onChange={e => update('total', e.target.value)} marginBottom={8} />
          </Pane>
          <Pane flex={1}>
            <label>Duration Seconds</label>
            <TextInput type='number' value={form.duration_sec} onChange={e => update('duration_sec', e.target.value)} marginBottom={8} />
          </Pane>
        </Pane>
        <Checkbox label='Insecure (Skip TLS)' checked={form.insecure} onChange={e => update('insecure', e.target.checked)} marginBottom={12} />
        <Checkbox label='Async (run in background)' checked={form.async} onChange={e => update('async', e.target.checked)} marginBottom={12} />
        {jobId && (
          <Pane marginBottom={12} background='tint1' padding={8} borderRadius={4}>
            <Text size={300}>Job: {jobId} Status: {jobStatus}</Text>
            {jobError && <Alert intent='danger' title='Job Error' marginTop={8}>{jobError}</Alert>}
            {polling && <Text size={300} display='block' color='muted'>Polling...</Text>}
            {polling && <Button marginTop={8} onClick={() => { stopPolling(); setJobStatus('CANCELLED') }} size='small'>Stop Polling</Button>}
          </Pane>
        )}
        <label>Request Data (JSON)</label>
  <Textarea value={form.data} onChange={onChangeData} height={160} marginBottom={8} />
        <label>Metadata (JSON)</label>
        <Textarea value={form.metadata} onChange={e => update('metadata', e.target.value)} height={64} marginBottom={8} />
        <label>Tags (JSON)</label>
        <Textarea value={form.tags} onChange={e => update('tags', e.target.value)} height={64} marginBottom={8} />
        <label>Proto File (Paste content)</label>
        <Textarea value={form.proto_file} onChange={e => update('proto_file', e.target.value)} height={140} marginBottom={16} placeholder='syntax = "proto3";\npackage helloworld;\n...' />
        <Button appearance='primary' intent='success' onClick={submit} disabled={loading}>
          {loading ? <><Spinner size={16} marginRight={8} /> Running...</> : 'Start'}
        </Button>
      </Pane>
    </Pane>
  )
}
